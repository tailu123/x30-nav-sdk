# 线程模型

X30 机器狗导航 SDK 采用了多线程设计，以提高性能和响应性。本文档将介绍 SDK 的线程模型和异步处理机制，帮助开发者理解 SDK 的内部工作原理。

## 线程概述

SDK 主要包含以下几种线程：

1. **主线程（Main Thread）**：用户应用程序的线程，调用 SDK 的公共 API
2. **IO 线程（IO Thread）**：处理网络 IO 操作的线程，由 Boost.Asio 管理
3. **回调线程（Callback Thread）**：执行用户回调函数的线程

下图展示了 SDK 的线程模型：

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│                 │     │                 │     │                 │
│    主线程        │     │    IO 线程      │     │   回调线程       │
│  Main Thread    │     │  IO Thread     │     │ Callback Thread │
│                 │     │                 │     │                 │
└────────┬────────┘     └────────┬────────┘     └────────┬────────┘
         │                       │                       │
         │                       │                       │
         │  调用 SDK API          │  处理网络 IO           │  执行用户回调
         │  Call SDK API         │  Handle Network IO    │  Execute Callbacks
         │                       │                       │
         ▼                       ▼                       ▼
┌───────────────────────────────────────────────────────────────────┐
│                                                                   │
│                       X30 机器狗导航 SDK                           │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

## 线程职责

### 1. 主线程（Main Thread）

主线程是用户应用程序的线程，负责：

- 调用 SDK 的公共 API
- 等待同步操作的结果
- 初始化和销毁 SDK 实例

主线程通常是用户应用程序的主线程或用户创建的工作线程。

### 2. IO 线程（IO Thread）

IO 线程是由 SDK 内部创建的线程，负责：

- 处理网络 IO 操作（发送和接收数据）
- 解析接收到的消息
- 触发网络事件回调

IO 线程由 Boost.Asio 的 `io_context` 管理，在 `AsioNetworkModel` 类中创建和维护。

### 3. 回调线程（Callback Thread）

回调线程负责执行用户提供的回调函数，包括：

- 事件回调（`EventCallback`）
- 导航任务结果回调（`NavigationResultCallback`）
- 实时状态回调（`RealTimeStatusCallback`）

回调线程通常是 IO 线程，但 SDK 使用 `strand` 机制确保回调函数的线程安全性。

## 线程同步

SDK 使用多种机制确保线程之间的同步：

1. **互斥锁（Mutex）**：保护共享数据的访问
2. **条件变量（Condition Variable）**：用于线程间的通知和等待
3. **原子变量（Atomic Variables）**：用于无锁的状态标志
4. **Strand**：确保异步操作按顺序执行，避免并发访问问题

## 同步操作与异步操作

SDK 提供了同步和异步两种操作方式：

### 同步操作

同步操作会阻塞调用线程，直到操作完成或超时：

```cpp
// 同步获取实时状态
auto status = sdk.getRealTimeStatus();

// 同步发送导航任务
auto result = sdk.startNavigation(points);

// 同步查询任务状态
auto taskStatus = sdk.queryTaskStatus();
```

同步操作的实现原理：

1. 创建请求消息并发送
2. 创建条件变量和互斥锁
3. 等待条件变量被通知或超时
4. 返回结果或抛出异常

### 异步操作

异步操作不会阻塞调用线程，而是通过回调函数通知操作结果：

```cpp
// 异步发送导航任务
sdk.startNavigationAsync(points, [](const NavigationResult& result) {
    // 处理结果
});
```

异步操作的实现原理：

1. 创建请求消息并发送
2. 保存回调函数
3. 当收到响应时，在 IO 线程中执行回调函数

## 线程生命周期

### 创建线程

1. **IO 线程**：在调用 `connect()` 方法时创建
2. **回调线程**：实际上是 IO 线程，不单独创建

### 销毁线程

1. **IO 线程**：在调用 `disconnect()` 方法或 SDK 析构时销毁
2. **回调线程**：随 IO 线程一起销毁

## 线程安全性

SDK 的设计确保了线程安全性：

1. **公共 API**：所有公共 API 都是线程安全的，可以从多个线程同时调用
2. **内部组件**：使用互斥锁、条件变量和 Strand 机制确保线程安全
3. **回调函数**：使用 Strand 机制确保回调函数按顺序执行，避免并发访问问题

## 异步事件通知

SDK 使用事件回调机制通知用户异步事件：

```cpp
// 设置事件回调
sdk.setEventCallback([](const Event& event) {
    // 处理事件
});
```

事件回调在 IO 线程中执行，通知用户以下事件：

- 连接建立（`EventType::CONNECTED`）
- 连接断开（`EventType::DISCONNECTED`）
- 连接错误（`EventType::CONNECTION_ERROR`）
- 其他系统事件

## 超时处理

SDK 对同步操作提供了超时处理机制：

1. **连接超时**：如果连接操作超过指定时间未完成，则返回失败
2. **请求超时**：如果请求未在指定时间内收到响应，则返回超时错误
3. **重连超时**：如果重连尝试超过指定次数，则停止重连

超时时间可以通过 `SdkOptions` 结构进行配置：

```cpp
SdkOptions options;
options.connectionTimeout = std::chrono::milliseconds(5000);  // 连接超时时间
options.requestTimeout = std::chrono::milliseconds(3000);     // 请求超时时间
options.reconnectInterval = std::chrono::milliseconds(1000);  // 重连间隔
```

## 自动重连机制

SDK 提供了自动重连机制，当连接断开时自动尝试重新连接：

1. **启用自动重连**：默认启用，可以通过 `SdkOptions` 配置
2. **重连间隔**：默认为 1 秒，可以通过 `SdkOptions` 配置
3. **最大重连次数**：默认为 3 次，可以通过 `SdkOptions` 配置

自动重连的工作原理：

1. 检测到连接断开
2. 等待指定的重连间隔
3. 尝试重新连接
4. 如果连接失败，重复步骤 2-3，直到达到最大重连次数或连接成功

## 最佳实践

为了充分利用 SDK 的线程模型，建议遵循以下最佳实践：

1. **使用异步操作**：对于耗时操作，使用异步方式避免阻塞主线程
2. **避免长时间回调**：在回调函数中避免执行耗时操作，以免阻塞 IO 线程
3. **正确处理异常**：捕获并处理回调函数中可能抛出的异常
4. **合理设置超时时间**：根据网络环境和业务需求设置合适的超时时间
5. **优雅关闭**：在应用程序退出前调用 `disconnect()` 方法，确保资源正确释放

## 总结

X30 机器狗导航 SDK 采用了多线程设计，通过主线程、IO 线程和回调线程的协作，提供了高性能、高响应性的导航控制功能。SDK 使用多种线程同步机制确保线程安全性，并提供了同步和异步两种操作方式，满足不同的使用场景。
